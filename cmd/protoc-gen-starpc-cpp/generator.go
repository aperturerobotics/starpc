package main

import (
	"path/filepath"
	"runtime/debug"
	"strings"

	"google.golang.org/protobuf/types/descriptorpb"
)

type generator struct {
	file    *descriptorpb.FileDescriptorProto
	fileMap map[string]*descriptorpb.FileDescriptorProto
	buf     strings.Builder
}

func (g *generator) P(args ...interface{}) {
	for _, arg := range args {
		switch v := arg.(type) {
		case string:
			g.buf.WriteString(v)
		default:
			// Handle other types if needed
		}
	}
	g.buf.WriteString("\n")
}

// GetServiceID returns the service id for the srpc.
func (g *generator) GetServiceID(service *descriptorpb.ServiceDescriptorProto) string {
	pkg := g.file.GetPackage()
	if pkg == "" {
		return service.GetName()
	}
	return pkg + "." + service.GetName()
}

// CppType returns the C++ type name for a protobuf message type.
func (g *generator) CppType(typeName string) string {
	// typeName is like ".package.MessageType" or ".MessageType"
	typeName = strings.TrimPrefix(typeName, ".")
	parts := strings.Split(typeName, ".")
	return strings.Join(parts, "::")
}

// ServiceGoName returns a Go-style name for the service.
func (g *generator) ServiceGoName(service *descriptorpb.ServiceDescriptorProto) string {
	return service.GetName()
}

// MethodGoName returns a Go-style name for the method.
func (g *generator) MethodGoName(method *descriptorpb.MethodDescriptorProto) string {
	return method.GetName()
}

// ClientIface returns the client interface name.
func (g *generator) ClientIface(service *descriptorpb.ServiceDescriptorProto) string {
	return "SRPC" + g.ServiceGoName(service) + "Client"
}

// ClientImpl returns the client implementation name.
func (g *generator) ClientImpl(service *descriptorpb.ServiceDescriptorProto) string {
	return "SRPC" + g.ServiceGoName(service) + "ClientImpl"
}

// ServerIface returns the server interface name.
func (g *generator) ServerIface(service *descriptorpb.ServiceDescriptorProto) string {
	return "SRPC" + g.ServiceGoName(service) + "Server"
}

// ServerServiceID returns the service ID constant name.
func (g *generator) ServerServiceID(service *descriptorpb.ServiceDescriptorProto) string {
	return "kSRPC" + g.ServiceGoName(service) + "ServiceID"
}

// ServerHandler returns the handler class name.
func (g *generator) ServerHandler(service *descriptorpb.ServiceDescriptorProto) string {
	return "SRPC" + g.ServiceGoName(service) + "Handler"
}

// ClientStreamIface returns the client stream interface name.
func (g *generator) ClientStreamIface(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) string {
	return "SRPC" +
		strings.ReplaceAll(g.ServiceGoName(service), "_", "__") + "_" +
		strings.ReplaceAll(g.MethodGoName(method), "_", "__") +
		"Client"
}

// ServerStreamIface returns the server stream interface name.
func (g *generator) ServerStreamIface(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) string {
	return "SRPC" +
		strings.ReplaceAll(g.ServiceGoName(service), "_", "__") + "_" +
		strings.ReplaceAll(g.MethodGoName(method), "_", "__") +
		"Stream"
}

// InputType returns the C++ input type for a method.
func (g *generator) InputType(method *descriptorpb.MethodDescriptorProto) string {
	return g.CppType(method.GetInputType())
}

// OutputType returns the C++ output type for a method.
func (g *generator) OutputType(method *descriptorpb.MethodDescriptorProto) string {
	return g.CppType(method.GetOutputType())
}

// generateHeader generates the .hpp header file.
func (g *generator) generateHeader() string {
	g.buf.Reset()

	g.P("// Code generated by protoc-gen-starpc-cpp. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		g.P("// protoc-gen-starpc-cpp version: ", bi.Main.Version)
	}
	g.P("// source: ", g.file.GetName())
	g.P()
	g.P("#pragma once")
	g.P()
	g.P("#include <functional>")
	g.P("#include <memory>")
	g.P("#include <string>")
	g.P("#include <utility>")
	g.P()
	g.P("#include \"srpc/starpc.hpp\"")
	g.P()

	// Include the protobuf header for this file (use basename for local includes)
	baseName := filepath.Base(g.file.GetName())
	pbHeader := strings.TrimSuffix(baseName, ".proto") + ".pb.h"
	g.P("#include \"", pbHeader, "\"")
	g.P()

	// Open namespace
	pkg := g.file.GetPackage()
	if pkg != "" {
		g.P("namespace ", strings.ReplaceAll(pkg, ".", "::"), " {")
		g.P()
	}

	for _, service := range g.file.Service {
		g.generateServiceHeader(service)
	}

	// Close namespace
	if pkg != "" {
		g.P("}  // namespace ", strings.ReplaceAll(pkg, ".", "::"))
	}

	return g.buf.String()
}

// generateSource generates the .cpp source file.
func (g *generator) generateSource() string {
	g.buf.Reset()

	// Add Go build constraint to exclude from Go compiler
	g.P("//go:build deps_only")
	g.P()
	g.P("// Code generated by protoc-gen-starpc-cpp. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		g.P("// protoc-gen-starpc-cpp version: ", bi.Main.Version)
	}
	g.P("// source: ", g.file.GetName())
	g.P()

	// Include the header (use basename for local includes)
	baseName := filepath.Base(g.file.GetName())
	hppFile := strings.TrimSuffix(baseName, ".proto") + "_srpc.pb.hpp"
	g.P("#include \"", hppFile, "\"")
	g.P()

	// Open namespace
	pkg := g.file.GetPackage()
	if pkg != "" {
		g.P("namespace ", strings.ReplaceAll(pkg, ".", "::"), " {")
		g.P()
	}

	for _, service := range g.file.Service {
		g.generateServiceSource(service)
	}

	// Close namespace
	if pkg != "" {
		g.P("}  // namespace ", strings.ReplaceAll(pkg, ".", "::"))
	}

	return g.buf.String()
}

// generateServiceHeader generates the header declarations for a service.
func (g *generator) generateServiceHeader(service *descriptorpb.ServiceDescriptorProto) {
	serviceID := g.GetServiceID(service)

	// Service ID constant
	g.P("// Service ID for ", g.ServiceGoName(service))
	g.P("constexpr const char* ", g.ServerServiceID(service), " = \"", serviceID, "\";")
	g.P()

	// Forward declarations for stream types
	for _, method := range service.Method {
		if method.GetServerStreaming() || method.GetClientStreaming() {
			g.P("class ", g.ClientStreamIface(service, method), ";")
			g.P("class ", g.ServerStreamIface(service, method), ";")
		}
	}
	g.P()

	// Client interface
	g.P("// ", g.ClientIface(service), " is the client API for ", g.ServiceGoName(service), " service.")
	g.P("class ", g.ClientIface(service), " {")
	g.P(" public:")
	g.P("  virtual ~", g.ClientIface(service), "() = default;")
	g.P()
	g.P("  // SRPCClient returns the underlying SRPC client.")
	g.P("  virtual starpc::Client* SRPCClient() = 0;")
	g.P()
	for _, method := range service.Method {
		g.generateClientMethodDecl(service, method, true) // interface = pure virtual
	}
	g.P("};")
	g.P()

	// Client implementation
	g.P("// ", g.ClientImpl(service), " implements ", g.ClientIface(service), ".")
	g.P("class ", g.ClientImpl(service), " : public ", g.ClientIface(service), " {")
	g.P(" public:")
	g.P("  explicit ", g.ClientImpl(service), "(starpc::Client* cc, const std::string& service_id = \"\")")
	g.P("      : cc_(cc), service_id_(service_id.empty() ? ", g.ServerServiceID(service), " : service_id) {}")
	g.P()
	g.P("  starpc::Client* SRPCClient() override { return cc_; }")
	g.P()
	for _, method := range service.Method {
		g.generateClientMethodDecl(service, method, false) // implementation = override
	}
	g.P()
	g.P(" private:")
	g.P("  starpc::Client* cc_;")
	g.P("  std::string service_id_;")
	g.P("};")
	g.P()

	// Factory function
	g.P("// New", g.ClientIface(service), " creates a new client.")
	g.P("inline std::unique_ptr<", g.ClientIface(service), "> New", g.ClientIface(service), "(starpc::Client* cc) {")
	g.P("  return std::make_unique<", g.ClientImpl(service), ">(cc);")
	g.P("}")
	g.P()

	// Server interface
	g.P("// ", g.ServerIface(service), " is the server API for ", g.ServiceGoName(service), " service.")
	g.P("class ", g.ServerIface(service), " {")
	g.P(" public:")
	g.P("  virtual ~", g.ServerIface(service), "() = default;")
	g.P()
	for _, method := range service.Method {
		g.generateServerMethodDecl(service, method)
	}
	g.P("};")
	g.P()

	// Handler implementation
	g.P("// ", g.ServerHandler(service), " implements starpc::Handler for ", g.ServiceGoName(service), ".")
	g.P("class ", g.ServerHandler(service), " : public starpc::Handler {")
	g.P(" public:")
	g.P("  ", g.ServerHandler(service), "(", g.ServerIface(service), "* impl, const std::string& service_id = \"\")")
	g.P("      : impl_(impl), service_id_(service_id.empty() ? ", g.ServerServiceID(service), " : service_id) {}")
	g.P()
	g.P("  const std::string& GetServiceID() const override { return service_id_; }")
	g.P("  std::vector<std::string> GetMethodIDs() const override;")
	g.P("  std::pair<bool, starpc::Error> InvokeMethod(")
	g.P("      const std::string& service_id,")
	g.P("      const std::string& method_id,")
	g.P("      starpc::Stream* strm) override;")
	g.P()
	g.P(" private:")
	g.P("  ", g.ServerIface(service), "* impl_;")
	g.P("  std::string service_id_;")
	g.P("};")
	g.P()

	// Registration helper functions
	g.P("// New", g.ServerHandler(service), " creates a new handler for the given implementation.")
	g.P("inline std::unique_ptr<", g.ServerHandler(service), "> New", g.ServerHandler(service), "(", g.ServerIface(service), "* impl) {")
	g.P("  return std::make_unique<", g.ServerHandler(service), ">(impl);")
	g.P("}")
	g.P()
	g.P("// SRPCRegister", g.ServiceGoName(service), " registers the server implementation with the mux.")
	g.P("// The returned handler must outlive the mux registration.")
	g.P("inline std::pair<std::unique_ptr<", g.ServerHandler(service), ">, starpc::Error> SRPCRegister", g.ServiceGoName(service), "(starpc::Mux* mux, ", g.ServerIface(service), "* impl) {")
	g.P("  auto handler = New", g.ServerHandler(service), "(impl);")
	g.P("  starpc::Error err = mux->Register(handler.get());")
	g.P("  if (err != starpc::Error::OK) {")
	g.P("    return {nullptr, err};")
	g.P("  }")
	g.P("  return {std::move(handler), starpc::Error::OK};")
	g.P("}")
	g.P()

	// Stream types for streaming methods
	for _, method := range service.Method {
		g.generateStreamTypes(service, method)
	}
}

// generateClientMethodDecl generates the client method declaration.
// If isInterface is true, generates pure virtual (= 0), otherwise override.
func (g *generator) generateClientMethodDecl(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto, isInterface bool) {
	inType := g.InputType(method)
	outType := g.OutputType(method)

	suffix := " = 0;"
	if !isInterface {
		suffix = " override;"
	}

	g.P("  // ", g.MethodGoName(method))
	if !method.GetServerStreaming() && !method.GetClientStreaming() {
		// Unary
		g.P("  virtual starpc::Error ", g.MethodGoName(method), "(const ", inType, "& in, ", outType, "* out)", suffix)
	} else if method.GetServerStreaming() && !method.GetClientStreaming() {
		// Server streaming
		g.P("  virtual std::pair<std::unique_ptr<", g.ClientStreamIface(service, method), ">, starpc::Error> ", g.MethodGoName(method), "(const ", inType, "& in)", suffix)
	} else if !method.GetServerStreaming() && method.GetClientStreaming() {
		// Client streaming
		g.P("  virtual std::pair<std::unique_ptr<", g.ClientStreamIface(service, method), ">, starpc::Error> ", g.MethodGoName(method), "()", suffix)
	} else {
		// Bidi streaming
		g.P("  virtual std::pair<std::unique_ptr<", g.ClientStreamIface(service, method), ">, starpc::Error> ", g.MethodGoName(method), "()", suffix)
	}
}

// generateServerMethodDecl generates the server method declaration.
func (g *generator) generateServerMethodDecl(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) {
	inType := g.InputType(method)
	outType := g.OutputType(method)

	g.P("  // ", g.MethodGoName(method))
	if !method.GetServerStreaming() && !method.GetClientStreaming() {
		// Unary
		g.P("  virtual starpc::Error ", g.MethodGoName(method), "(const ", inType, "& req, ", outType, "* resp) = 0;")
	} else if method.GetServerStreaming() && !method.GetClientStreaming() {
		// Server streaming
		g.P("  virtual starpc::Error ", g.MethodGoName(method), "(const ", inType, "& req, ", g.ServerStreamIface(service, method), "* strm) = 0;")
	} else if !method.GetServerStreaming() && method.GetClientStreaming() {
		// Client streaming
		g.P("  virtual starpc::Error ", g.MethodGoName(method), "(", g.ServerStreamIface(service, method), "* strm, ", outType, "* resp) = 0;")
	} else {
		// Bidi streaming
		g.P("  virtual starpc::Error ", g.MethodGoName(method), "(", g.ServerStreamIface(service, method), "* strm) = 0;")
	}
}

// generateStreamTypes generates stream wrapper types for streaming methods.
func (g *generator) generateStreamTypes(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) {
	if !method.GetServerStreaming() && !method.GetClientStreaming() {
		return
	}

	inType := g.InputType(method)
	outType := g.OutputType(method)

	// Client stream interface
	g.P("// ", g.ClientStreamIface(service, method), " is the client stream for ", g.MethodGoName(method), ".")
	g.P("class ", g.ClientStreamIface(service, method), " {")
	g.P(" public:")
	g.P("  explicit ", g.ClientStreamIface(service, method), "(std::unique_ptr<starpc::Stream> strm) : strm_(std::move(strm)) {}")
	g.P()

	if method.GetClientStreaming() {
		g.P("  starpc::Error Send(const ", inType, "& msg) {")
		g.P("    return strm_->MsgSend(msg);")
		g.P("  }")
		g.P()
	}

	if method.GetServerStreaming() {
		g.P("  starpc::Error Recv(", outType, "* msg) {")
		g.P("    return strm_->MsgRecv(msg);")
		g.P("  }")
		g.P()
	}

	if method.GetClientStreaming() && !method.GetServerStreaming() {
		// Client streaming - CloseAndRecv
		g.P("  starpc::Error CloseAndRecv(", outType, "* msg) {")
		g.P("    starpc::Error err = strm_->CloseSend();")
		g.P("    if (err != starpc::Error::OK) return err;")
		g.P("    return strm_->MsgRecv(msg);")
		g.P("  }")
		g.P()
	}

	g.P("  starpc::Error CloseSend() { return strm_->CloseSend(); }")
	g.P("  starpc::Error Close() { return strm_->Close(); }")
	g.P()
	g.P(" private:")
	g.P("  std::unique_ptr<starpc::Stream> strm_;")
	g.P("};")
	g.P()

	// Server stream interface
	g.P("// ", g.ServerStreamIface(service, method), " is the server stream for ", g.MethodGoName(method), ".")
	g.P("class ", g.ServerStreamIface(service, method), " {")
	g.P(" public:")
	g.P("  explicit ", g.ServerStreamIface(service, method), "(starpc::Stream* strm) : strm_(strm) {}")
	g.P()

	if method.GetServerStreaming() {
		g.P("  starpc::Error Send(const ", outType, "& msg) {")
		g.P("    return strm_->MsgSend(msg);")
		g.P("  }")
		g.P()
		g.P("  starpc::Error SendAndClose(const ", outType, "& msg) {")
		g.P("    starpc::Error err = strm_->MsgSend(msg);")
		g.P("    if (err != starpc::Error::OK) return err;")
		g.P("    return strm_->CloseSend();")
		g.P("  }")
		g.P()
	}

	if method.GetClientStreaming() {
		g.P("  starpc::Error Recv(", inType, "* msg) {")
		g.P("    return strm_->MsgRecv(msg);")
		g.P("  }")
		g.P()
	}

	g.P(" private:")
	g.P("  starpc::Stream* strm_;")
	g.P("};")
	g.P()
}

// generateServiceSource generates the implementation for a service.
func (g *generator) generateServiceSource(service *descriptorpb.ServiceDescriptorProto) {
	// Client method implementations
	for _, method := range service.Method {
		g.generateClientMethodImpl(service, method)
	}

	// Handler GetMethodIDs
	g.P("std::vector<std::string> ", g.ServerHandler(service), "::GetMethodIDs() const {")
	g.P("  return {")
	for _, method := range service.Method {
		g.P("    \"", g.MethodGoName(method), "\",")
	}
	g.P("  };")
	g.P("}")
	g.P()

	// Handler InvokeMethod
	g.P("std::pair<bool, starpc::Error> ", g.ServerHandler(service), "::InvokeMethod(")
	g.P("    const std::string& service_id,")
	g.P("    const std::string& method_id,")
	g.P("    starpc::Stream* strm) {")
	g.P("  if (!service_id.empty() && service_id != service_id_) {")
	g.P("    return {false, starpc::Error::OK};")
	g.P("  }")
	g.P()
	for i, method := range service.Method {
		methodID := g.MethodGoName(method)
		if i == 0 {
			g.P("  if (method_id == \"", methodID, "\") {")
		} else {
			g.P("  } else if (method_id == \"", methodID, "\") {")
		}
		g.generateInvokeMethodBody(service, method)
	}
	g.P("  }")
	g.P()
	g.P("  return {false, starpc::Error::OK};")
	g.P("}")
	g.P()
}

// generateClientMethodImpl generates the client method implementation.
func (g *generator) generateClientMethodImpl(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) {
	inType := g.InputType(method)
	outType := g.OutputType(method)
	methodID := g.MethodGoName(method)

	if !method.GetServerStreaming() && !method.GetClientStreaming() {
		// Unary
		g.P("starpc::Error ", g.ClientImpl(service), "::", g.MethodGoName(method), "(const ", inType, "& in, ", outType, "* out) {")
		g.P("  return cc_->ExecCall(service_id_, \"", methodID, "\", in, out);")
		g.P("}")
	} else if method.GetServerStreaming() && !method.GetClientStreaming() {
		// Server streaming
		g.P("std::pair<std::unique_ptr<", g.ClientStreamIface(service, method), ">, starpc::Error> ",
			g.ClientImpl(service), "::", g.MethodGoName(method), "(const ", inType, "& in) {")
		g.P("  auto [strm, err] = cc_->NewStream(service_id_, \"", methodID, "\", &in);")
		g.P("  if (err != starpc::Error::OK) {")
		g.P("    return {nullptr, err};")
		g.P("  }")
		g.P("  err = strm->CloseSend();")
		g.P("  if (err != starpc::Error::OK) {")
		g.P("    return {nullptr, err};")
		g.P("  }")
		g.P("  return {std::make_unique<", g.ClientStreamIface(service, method), ">(std::move(strm)), starpc::Error::OK};")
		g.P("}")
	} else if !method.GetServerStreaming() && method.GetClientStreaming() {
		// Client streaming
		g.P("std::pair<std::unique_ptr<", g.ClientStreamIface(service, method), ">, starpc::Error> ",
			g.ClientImpl(service), "::", g.MethodGoName(method), "() {")
		g.P("  auto [strm, err] = cc_->NewStream(service_id_, \"", methodID, "\", nullptr);")
		g.P("  if (err != starpc::Error::OK) {")
		g.P("    return {nullptr, err};")
		g.P("  }")
		g.P("  return {std::make_unique<", g.ClientStreamIface(service, method), ">(std::move(strm)), starpc::Error::OK};")
		g.P("}")
	} else {
		// Bidi streaming
		g.P("std::pair<std::unique_ptr<", g.ClientStreamIface(service, method), ">, starpc::Error> ",
			g.ClientImpl(service), "::", g.MethodGoName(method), "() {")
		g.P("  auto [strm, err] = cc_->NewStream(service_id_, \"", methodID, "\", nullptr);")
		g.P("  if (err != starpc::Error::OK) {")
		g.P("    return {nullptr, err};")
		g.P("  }")
		g.P("  return {std::make_unique<", g.ClientStreamIface(service, method), ">(std::move(strm)), starpc::Error::OK};")
		g.P("}")
	}
	g.P()
}

// generateInvokeMethodBody generates the body of InvokeMethod for a specific method.
func (g *generator) generateInvokeMethodBody(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) {
	inType := g.InputType(method)
	outType := g.OutputType(method)

	if !method.GetServerStreaming() && !method.GetClientStreaming() {
		// Unary
		g.P("    ", inType, " req;")
		g.P("    starpc::Error err = strm->MsgRecv(&req);")
		g.P("    if (err != starpc::Error::OK) return {true, err};")
		g.P("    ", outType, " resp;")
		g.P("    err = impl_->", g.MethodGoName(method), "(req, &resp);")
		g.P("    if (err != starpc::Error::OK) return {true, err};")
		g.P("    return {true, strm->MsgSend(resp)};")
	} else if method.GetServerStreaming() && !method.GetClientStreaming() {
		// Server streaming
		g.P("    ", inType, " req;")
		g.P("    starpc::Error err = strm->MsgRecv(&req);")
		g.P("    if (err != starpc::Error::OK) return {true, err};")
		g.P("    ", g.ServerStreamIface(service, method), " serverStrm(strm);")
		g.P("    return {true, impl_->", g.MethodGoName(method), "(req, &serverStrm)};")
	} else if !method.GetServerStreaming() && method.GetClientStreaming() {
		// Client streaming
		g.P("    ", g.ServerStreamIface(service, method), " clientStrm(strm);")
		g.P("    ", outType, " resp;")
		g.P("    starpc::Error err = impl_->", g.MethodGoName(method), "(&clientStrm, &resp);")
		g.P("    if (err != starpc::Error::OK) return {true, err};")
		g.P("    return {true, strm->MsgSend(resp)};")
	} else {
		// Bidi streaming
		g.P("    ", g.ServerStreamIface(service, method), " bidiStrm(strm);")
		g.P("    return {true, impl_->", g.MethodGoName(method), "(&bidiStrm)};")
	}
}
