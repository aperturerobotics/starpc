package main

import (
	"fmt"
	"runtime/debug"
	"strings"
	"unicode"

	"google.golang.org/protobuf/types/descriptorpb"
)

type generator struct {
	file    *descriptorpb.FileDescriptorProto
	fileMap map[string]*descriptorpb.FileDescriptorProto
	buf     strings.Builder
}

func (g *generator) P(args ...interface{}) {
	for _, arg := range args {
		switch v := arg.(type) {
		case string:
			g.buf.WriteString(v)
		default:
		}
	}
	g.buf.WriteString("\n")
}

// GetServiceID returns the service id for the srpc.
func (g *generator) GetServiceID(service *descriptorpb.ServiceDescriptorProto) string {
	pkg := g.file.GetPackage()
	if pkg == "" {
		return service.GetName()
	}
	return pkg + "." + service.GetName()
}

// RustType returns the Rust type name for a protobuf message type.
func (g *generator) RustType(typeName string) string {
	// typeName is like ".package.MessageType" or ".MessageType"
	typeName = strings.TrimPrefix(typeName, ".")
	parts := strings.Split(typeName, ".")
	// Return just the message name - caller should add proper module prefix if needed.
	return parts[len(parts)-1]
}

// ServiceGoName returns a name for the service.
func (g *generator) ServiceGoName(service *descriptorpb.ServiceDescriptorProto) string {
	return service.GetName()
}

// MethodGoName returns a name for the method.
func (g *generator) MethodGoName(method *descriptorpb.MethodDescriptorProto) string {
	return method.GetName()
}

// toSnakeCase converts PascalCase to snake_case.
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				result.WriteByte('_')
			}
			result.WriteRune(unicode.ToLower(r))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// toScreamingSnakeCase converts a name to SCREAMING_SNAKE_CASE.
func toScreamingSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				result.WriteByte('_')
			}
			result.WriteRune(r)
		} else {
			result.WriteRune(unicode.ToUpper(r))
		}
	}
	return result.String()
}

// ClientIface returns the client trait name.
func (g *generator) ClientIface(service *descriptorpb.ServiceDescriptorProto) string {
	return g.ServiceGoName(service) + "Client"
}

// ClientImpl returns the client implementation name.
func (g *generator) ClientImpl(service *descriptorpb.ServiceDescriptorProto) string {
	return g.ServiceGoName(service) + "ClientImpl"
}

// ServerIface returns the server trait name.
func (g *generator) ServerIface(service *descriptorpb.ServiceDescriptorProto) string {
	return g.ServiceGoName(service) + "Server"
}

// ServerServiceID returns the service ID constant name.
func (g *generator) ServerServiceID(service *descriptorpb.ServiceDescriptorProto) string {
	return toScreamingSnakeCase(g.ServiceGoName(service)) + "_SERVICE_ID"
}

// ServerHandler returns the handler struct name.
func (g *generator) ServerHandler(service *descriptorpb.ServiceDescriptorProto) string {
	return g.ServiceGoName(service) + "Handler"
}

// ClientStreamIface returns the client stream trait name.
func (g *generator) ClientStreamIface(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) string {
	return g.ServiceGoName(service) + g.MethodGoName(method) + "Stream"
}

// ServerStreamIface returns the server stream trait name.
func (g *generator) ServerStreamIface(service *descriptorpb.ServiceDescriptorProto, method *descriptorpb.MethodDescriptorProto) string {
	return g.ServiceGoName(service) + g.MethodGoName(method) + "ServerStream"
}

// InputType returns the Rust input type for a method.
func (g *generator) InputType(method *descriptorpb.MethodDescriptorProto) string {
	return g.RustType(method.GetInputType())
}

// OutputType returns the Rust output type for a method.
func (g *generator) OutputType(method *descriptorpb.MethodDescriptorProto) string {
	return g.RustType(method.GetOutputType())
}

// generate generates the Rust source file.
func (g *generator) generate() string {
	g.buf.Reset()

	g.P("// Code generated by protoc-gen-starpc-rust. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		g.P("// protoc-gen-starpc-rust version: ", bi.Main.Version)
	}
	g.P("// source: ", g.file.GetName())
	g.P()
	g.P("#[allow(unused_imports)]")
	g.P("use starpc::StreamExt;")
	g.P()

	for _, service := range g.file.Service {
		g.generateService(service)
	}

	return g.buf.String()
}

// generateService generates all code for a service.
func (g *generator) generateService(service *descriptorpb.ServiceDescriptorProto) {
	serviceID := g.GetServiceID(service)

	// Service ID constant.
	g.P("/// Service ID for ", g.ServiceGoName(service), ".")
	g.P("pub const ", g.ServerServiceID(service), ": &str = \"", serviceID, "\";")
	g.P()

	// Generate stream traits for streaming methods.
	g.generateStreamTraits(service)

	// Generate client trait.
	g.generateClientTrait(service)

	// Generate client implementation.
	g.generateClientImpl(service)

	// Generate stream implementations.
	g.generateStreamImpls(service)

	// Generate server trait.
	g.generateServerTrait(service)

	// Generate handler.
	g.generateHandler(service)
}

// generateStreamTraits generates stream traits for streaming methods.
func (g *generator) generateStreamTraits(service *descriptorpb.ServiceDescriptorProto) {
	for _, method := range service.Method {
		if !method.GetClientStreaming() && !method.GetServerStreaming() {
			continue
		}

		inputType := g.InputType(method)
		outputType := g.OutputType(method)

		g.P("/// Stream trait for ", g.ServiceGoName(service), ".", g.MethodGoName(method), ".")
		g.P("#[starpc::async_trait]")
		g.P("pub trait ", g.ClientStreamIface(service, method), ": Send + Sync {")
		g.P("    /// Returns the context for this stream.")
		g.P("    fn context(&self) -> &starpc::Context;")

		if method.GetClientStreaming() {
			g.P("    /// Sends a message on the stream.")
			g.P("    async fn send(&self, msg: &", inputType, ") -> starpc::Result<()>;")
		}

		if method.GetServerStreaming() {
			g.P("    /// Receives a message from the stream.")
			g.P("    async fn recv(&self) -> starpc::Result<", outputType, ">;")
		}

		if method.GetClientStreaming() && !method.GetServerStreaming() {
			// Client streaming - need close_and_recv for the final response.
			g.P("    /// Closes the send side and receives the response.")
			g.P("    async fn close_and_recv(&self) -> starpc::Result<", outputType, ">;")
		} else {
			g.P("    /// Closes the stream.")
			g.P("    async fn close(&self) -> starpc::Result<()>;")
		}

		g.P("}")
		g.P()
	}
}

// generateClientTrait generates the client trait.
func (g *generator) generateClientTrait(service *descriptorpb.ServiceDescriptorProto) {
	g.P("/// Client trait for ", g.ServiceGoName(service), ".")
	g.P("#[starpc::async_trait]")
	g.P("pub trait ", g.ClientIface(service), ": Send + Sync {")

	for _, method := range service.Method {
		inputType := g.InputType(method)
		outputType := g.OutputType(method)
		methodName := toSnakeCase(g.MethodGoName(method))

		g.P("    /// ", g.MethodGoName(method), ".")

		if method.GetClientStreaming() && method.GetServerStreaming() {
			// Bidirectional streaming.
			g.P("    async fn ", methodName, "(&self) -> starpc::Result<Box<dyn ", g.ClientStreamIface(service, method), ">>;")
		} else if method.GetServerStreaming() {
			// Server streaming.
			g.P("    async fn ", methodName, "(&self, request: &", inputType, ") -> starpc::Result<Box<dyn ", g.ClientStreamIface(service, method), ">>;")
		} else if method.GetClientStreaming() {
			// Client streaming.
			g.P("    async fn ", methodName, "(&self) -> starpc::Result<Box<dyn ", g.ClientStreamIface(service, method), ">>;")
		} else {
			// Unary.
			g.P("    async fn ", methodName, "(&self, request: &", inputType, ") -> starpc::Result<", outputType, ">;")
		}
	}

	g.P("}")
	g.P()
}

// generateClientImpl generates the client implementation.
func (g *generator) generateClientImpl(service *descriptorpb.ServiceDescriptorProto) {
	serviceID := g.GetServiceID(service)

	g.P("/// Client implementation for ", g.ServiceGoName(service), ".")
	g.P("pub struct ", g.ClientImpl(service), "<C> {")
	g.P("    client: C,")
	g.P("}")
	g.P()

	g.P("impl<C: starpc::Client> ", g.ClientImpl(service), "<C> {")
	g.P("    /// Creates a new client.")
	g.P("    pub fn new(client: C) -> Self {")
	g.P("        Self { client }")
	g.P("    }")
	g.P("}")
	g.P()

	g.P("#[starpc::async_trait]")
	g.P("impl<C: starpc::Client + 'static> ", g.ClientIface(service), " for ", g.ClientImpl(service), "<C> {")

	for _, method := range service.Method {
		inputType := g.InputType(method)
		outputType := g.OutputType(method)
		methodName := toSnakeCase(g.MethodGoName(method))

		if method.GetClientStreaming() && method.GetServerStreaming() {
			// Bidirectional streaming.
			g.P("    async fn ", methodName, "(&self) -> starpc::Result<Box<dyn ", g.ClientStreamIface(service, method), ">> {")
			g.P("        let stream = self.client.new_stream(\"", serviceID, "\", \"", g.MethodGoName(method), "\", None).await?;")
			g.P("        Ok(Box::new(", g.ClientStreamIface(service, method), "Impl { stream }))")
			g.P("    }")
		} else if method.GetServerStreaming() {
			// Server streaming.
			g.P("    async fn ", methodName, "(&self, request: &", inputType, ") -> starpc::Result<Box<dyn ", g.ClientStreamIface(service, method), ">> {")
			g.P("        use starpc::ProstMessage;")
			g.P("        let data = request.encode_to_vec();")
			g.P("        let stream = self.client.new_stream(\"", serviceID, "\", \"", g.MethodGoName(method), "\", Some(&data)).await?;")
			g.P("        stream.close_send().await?;")
			g.P("        Ok(Box::new(", g.ClientStreamIface(service, method), "Impl { stream }))")
			g.P("    }")
		} else if method.GetClientStreaming() {
			// Client streaming.
			g.P("    async fn ", methodName, "(&self) -> starpc::Result<Box<dyn ", g.ClientStreamIface(service, method), ">> {")
			g.P("        let stream = self.client.new_stream(\"", serviceID, "\", \"", g.MethodGoName(method), "\", None).await?;")
			g.P("        Ok(Box::new(", g.ClientStreamIface(service, method), "Impl { stream }))")
			g.P("    }")
		} else {
			// Unary.
			g.P("    async fn ", methodName, "(&self, request: &", inputType, ") -> starpc::Result<", outputType, "> {")
			g.P("        self.client.exec_call(\"", serviceID, "\", \"", g.MethodGoName(method), "\", request).await")
			g.P("    }")
		}
	}

	g.P("}")
	g.P()
}

// generateStreamImpls generates stream implementation structs.
func (g *generator) generateStreamImpls(service *descriptorpb.ServiceDescriptorProto) {
	for _, method := range service.Method {
		if !method.GetClientStreaming() && !method.GetServerStreaming() {
			continue
		}

		inputType := g.InputType(method)
		outputType := g.OutputType(method)

		g.P("struct ", g.ClientStreamIface(service, method), "Impl {")
		g.P("    stream: Box<dyn starpc::Stream>,")
		g.P("}")
		g.P()

		g.P("#[starpc::async_trait]")
		g.P("impl ", g.ClientStreamIface(service, method), " for ", g.ClientStreamIface(service, method), "Impl {")
		g.P("    fn context(&self) -> &starpc::Context {")
		g.P("        self.stream.context()")
		g.P("    }")

		if method.GetClientStreaming() {
			g.P("    async fn send(&self, msg: &", inputType, ") -> starpc::Result<()> {")
			g.P("        self.stream.msg_send(msg).await")
			g.P("    }")
		}

		if method.GetServerStreaming() {
			g.P("    async fn recv(&self) -> starpc::Result<", outputType, "> {")
			g.P("        self.stream.msg_recv().await")
			g.P("    }")
		}

		if method.GetClientStreaming() && !method.GetServerStreaming() {
			g.P("    async fn close_and_recv(&self) -> starpc::Result<", outputType, "> {")
			g.P("        self.stream.close_send().await?;")
			g.P("        self.stream.msg_recv().await")
			g.P("    }")
		} else {
			g.P("    async fn close(&self) -> starpc::Result<()> {")
			g.P("        self.stream.close().await")
			g.P("    }")
		}

		g.P("}")
		g.P()
	}
}

// generateServerTrait generates the server trait.
func (g *generator) generateServerTrait(service *descriptorpb.ServiceDescriptorProto) {
	g.P("/// Server trait for ", g.ServiceGoName(service), ".")
	g.P("#[starpc::async_trait]")
	g.P("pub trait ", g.ServerIface(service), ": Send + Sync {")

	for _, method := range service.Method {
		inputType := g.InputType(method)
		outputType := g.OutputType(method)
		methodName := toSnakeCase(g.MethodGoName(method))

		g.P("    /// ", g.MethodGoName(method), ".")

		if method.GetClientStreaming() && method.GetServerStreaming() {
			// Bidirectional streaming.
			g.P("    async fn ", methodName, "(&self, stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;")
		} else if method.GetServerStreaming() {
			// Server streaming.
			g.P("    async fn ", methodName, "(&self, request: ", inputType, ", stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;")
		} else if method.GetClientStreaming() {
			// Client streaming.
			g.P("    async fn ", methodName, "(&self, stream: &dyn starpc::Stream) -> starpc::Result<", outputType, ">;")
		} else {
			// Unary.
			g.P("    async fn ", methodName, "(&self, request: ", inputType, ") -> starpc::Result<", outputType, ">;")
		}
	}

	g.P("}")
	g.P()
}

// generateHandler generates the handler struct and implementations.
func (g *generator) generateHandler(service *descriptorpb.ServiceDescriptorProto) {
	serviceID := g.GetServiceID(service)

	// Generate method IDs constant.
	g.P("const ", toScreamingSnakeCase(g.ServiceGoName(service)), "_METHOD_IDS: &[&str] = &[")
	for _, method := range service.Method {
		g.P("    \"", g.MethodGoName(method), "\",")
	}
	g.P("];")
	g.P()

	// Generate handler struct.
	g.P("/// Handler for ", g.ServiceGoName(service), ".")
	g.P("pub struct ", g.ServerHandler(service), "<S: ", g.ServerIface(service), "> {")
	g.P("    server: std::sync::Arc<S>,")
	g.P("}")
	g.P()

	g.P("impl<S: ", g.ServerIface(service), " + 'static> ", g.ServerHandler(service), "<S> {")
	g.P("    /// Creates a new handler wrapping the server implementation.")
	g.P("    pub fn new(server: S) -> Self {")
	g.P("        Self { server: std::sync::Arc::new(server) }")
	g.P("    }")
	g.P()
	g.P("    /// Creates a new handler with a shared server.")
	g.P("    pub fn with_arc(server: std::sync::Arc<S>) -> Self {")
	g.P("        Self { server }")
	g.P("    }")
	g.P("}")
	g.P()

	// Implement Invoker trait.
	g.P("#[starpc::async_trait]")
	g.P("impl<S: ", g.ServerIface(service), " + 'static> starpc::Invoker for ", g.ServerHandler(service), "<S> {")
	g.P("    async fn invoke_method(")
	g.P("        &self,")
	g.P("        _service_id: &str,")
	g.P("        method_id: &str,")
	g.P("        stream: Box<dyn starpc::Stream>,")
	g.P("    ) -> (bool, starpc::Result<()>) {")
	g.P("        match method_id {")

	for _, method := range service.Method {
		inputType := g.InputType(method)
		methodName := toSnakeCase(g.MethodGoName(method))

		g.P("            \"", g.MethodGoName(method), "\" => {")

		if method.GetClientStreaming() && method.GetServerStreaming() {
			// Bidirectional streaming.
			g.P("                (true, self.server.", methodName, "(stream).await)")
		} else if method.GetServerStreaming() {
			// Server streaming - receive request first.
			g.P("                let request: ", inputType, " = match stream.msg_recv().await {")
			g.P("                    Ok(r) => r,")
			g.P("                    Err(e) => return (true, Err(e)),")
			g.P("                };")
			g.P("                (true, self.server.", methodName, "(request, stream).await)")
		} else if method.GetClientStreaming() {
			// Client streaming - receive messages, then send response.
			g.P("                match self.server.", methodName, "(stream.as_ref()).await {")
			g.P("                    Ok(response) => {")
			g.P("                        if let Err(e) = stream.msg_send(&response).await {")
			g.P("                            return (true, Err(e));")
			g.P("                        }")
			g.P("                        (true, Ok(()))")
			g.P("                    }")
			g.P("                    Err(e) => (true, Err(e)),")
			g.P("                }")
		} else {
			// Unary.
			g.P("                let request: ", inputType, " = match stream.msg_recv().await {")
			g.P("                    Ok(r) => r,")
			g.P("                    Err(e) => return (true, Err(e)),")
			g.P("                };")
			g.P("                match self.server.", methodName, "(request).await {")
			g.P("                    Ok(response) => {")
			g.P("                        if let Err(e) = stream.msg_send(&response).await {")
			g.P("                            return (true, Err(e));")
			g.P("                        }")
			g.P("                        (true, Ok(()))")
			g.P("                    }")
			g.P("                    Err(e) => (true, Err(e)),")
			g.P("                }")
		}

		g.P("            }")
	}

	g.P("            _ => (false, Err(starpc::Error::Unimplemented)),")
	g.P("        }")
	g.P("    }")
	g.P("}")
	g.P()

	// Implement Handler trait.
	g.P("impl<S: ", g.ServerIface(service), " + 'static> starpc::Handler for ", g.ServerHandler(service), "<S> {")
	g.P("    fn service_id(&self) -> &'static str {")
	g.P(fmt.Sprintf("        \"%s\"", serviceID))
	g.P("    }")
	g.P()
	g.P("    fn method_ids(&self) -> &'static [&'static str] {")
	g.P("        ", toScreamingSnakeCase(g.ServiceGoName(service)), "_METHOD_IDS")
	g.P("    }")
	g.P("}")
	g.P()
}
