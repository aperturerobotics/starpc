diff --git a/node_modules/ts-poet/build/Import.js b/node_modules/ts-poet/build/Import.js
index 955a7eb..8c8b806 100644
--- a/node_modules/ts-poet/build/Import.js
+++ b/node_modules/ts-poet/build/Import.js
@@ -6,6 +6,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.sameModule = exports.maybeRelativePath = exports.emitImports = exports.SideEffect = exports.Augmented = exports.ImportsAll = exports.ImportsDefault = exports.ImportsName = exports.Imported = exports.Implicit = exports.Import = exports.importType = void 0;
 const lodash_1 = __importDefault(require("lodash"));
 const path_1 = __importDefault(require("path"));
+const path = require("path");
 const Node_1 = require("./Node");
 const typeImportMarker = '(?:t:)?';
 const fileNamePattern = '(?:[a-zA-Z0-9._-]+)';
@@ -288,6 +289,16 @@ function emitImports(imports, ourModulePath, importMappings) {
         if (modulePath in importMappings) {
             modulePath = importMappings[modulePath];
         }
+      const thisProject = 'github.com/aperturerobotics/starpc';
+      if (ourModulePath.startsWith(thisProject)) {
+        // throw new Error(ourModulePath + ' : ' + modulePath);
+        const projectModulePath = path.dirname(ourModulePath.substring(thisProject.length))
+        ourModulePath = "./" + projectModulePath
+      }
+      if (modulePath.startsWith('./')) {
+        modulePath = modulePath.substr(2);
+        modulePath = './vendor/' + modulePath;
+      }
         const importPath = maybeRelativePath(ourModulePath, modulePath);
         // Output star imports individually
         unique(filterInstances(imports, ImportsAll).map((i) => i.symbol)).forEach((symbol) => {
@@ -337,17 +348,15 @@ function maybeRelativePath(outputPath, importPath) {
     if (!importPath.startsWith('./')) {
         return importPath;
     }
-    // Drop the `./` prefix from the outputPath if it exists.
-    const basePath = outputPath.replace(/^.\//, '');
-    // Ideally we'd use a path library to do all this.
-    const numberOfDirs = basePath.split('').filter((l) => l === '/').length;
-    if (numberOfDirs === 0) {
-        return importPath;
-    }
-    // Make an array of `..` to get our importPath to the root directory.
-    const a = new Array(numberOfDirs);
-    const prefix = a.fill('..', 0, numberOfDirs).join('/');
-    return prefix + importPath.substring(1);
+    // Drop the last element of importPath.
+    // const importPathDir = path.dirname(importPath);
+    // const outputPathDir = path.dirname(outputPath);
+    // TODO
+    // throw new Error('basePath: ' + basePath + ' importPath: ' + importPathDir);
+    // Get the relative path from basePath to importPathDir.
+    // return path.relative(basePath, importPathDir);
+    // return path.relative(outputPathDir, importPath);
+    return path.relative(outputPath, importPath);
 }
 exports.maybeRelativePath = maybeRelativePath;
 /** Checks if `path1 === path2` despite minor path differences like `./foo` and `foo`. */
