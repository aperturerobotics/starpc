diff --git a/node_modules/ts-poet/build/Import.js b/node_modules/ts-poet/build/Import.js
index 955a7eb..0ad3a67 100644
--- a/node_modules/ts-poet/build/Import.js
+++ b/node_modules/ts-poet/build/Import.js
@@ -6,6 +6,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.sameModule = exports.maybeRelativePath = exports.emitImports = exports.SideEffect = exports.Augmented = exports.ImportsAll = exports.ImportsDefault = exports.ImportsName = exports.Imported = exports.Implicit = exports.Import = exports.importType = void 0;
 const lodash_1 = __importDefault(require("lodash"));
 const path_1 = __importDefault(require("path"));
+const path = require("path");
 const Node_1 = require("./Node");
 const typeImportMarker = '(?:t:)?';
 const fileNamePattern = '(?:[a-zA-Z0-9._-]+)';
@@ -274,6 +275,15 @@ function emitImports(imports, ourModulePath, importMappings) {
         return '';
     }
     let result = '';
+    const thisProject = process.env.PROJECT;
+    let ourModuleImportPath = path.normalize(ourModulePath);
+    // HACK: if this is an import from our project, set the path accordingly
+    // github.com/aperturerobotics/protobuf-project/example/example -> ./example/example
+    if (thisProject && ourModuleImportPath.startsWith(thisProject)) {
+        ourModuleImportPath = './' + ourModuleImportPath.substr(thisProject.length + 1);
+    }
+    // result += `// ourModulePath: ${ourModulePath}\n`;
+    // result += `// ourModuleImportPath: ${ourModuleImportPath}\n`;
     const augmentImports = lodash_1.default.groupBy(filterInstances(imports, Augmented), (a) => a.augmented);
     // Group the imports by source module they're imported from
     const importsByModule = lodash_1.default.groupBy(imports.filter((it) => it.source !== undefined &&
@@ -288,7 +298,16 @@ function emitImports(imports, ourModulePath, importMappings) {
         if (modulePath in importMappings) {
             modulePath = importMappings[modulePath];
         }
-        const importPath = maybeRelativePath(ourModulePath, modulePath);
+        // HACK: if this is an import from a different project, use vendor/ tree.
+        if (thisProject && modulePath.startsWith('./')) {
+            if (!modulePath.substr(2).startsWith(thisProject)) {
+                modulePath = './vendor/' + path.normalize(modulePath);
+            } else {
+                modulePath = './' + modulePath.substr(3 + thisProject.length);
+            }
+        }
+        // result += `// modulePath: ${modulePath}\n`;
+        const importPath = maybeRelativePath(ourModuleImportPath, modulePath);
         // Output star imports individually
         unique(filterInstances(imports, ImportsAll).map((i) => i.symbol)).forEach((symbol) => {
             result += `import * as ${symbol} from '${importPath}';\n`;
@@ -337,17 +356,15 @@ function maybeRelativePath(outputPath, importPath) {
     if (!importPath.startsWith('./')) {
         return importPath;
     }
-    // Drop the `./` prefix from the outputPath if it exists.
-    const basePath = outputPath.replace(/^.\//, '');
-    // Ideally we'd use a path library to do all this.
-    const numberOfDirs = basePath.split('').filter((l) => l === '/').length;
-    if (numberOfDirs === 0) {
-        return importPath;
+    importPath = path.normalize(importPath);
+    outputPath = path.normalize(outputPath);
+    const outputPathDir = path.dirname(outputPath);
+    let relativePath = path.relative(outputPathDir, importPath);
+    if (!relativePath.startsWith('.')) {
+      // ensure the js compiler recognizes this is a relative path.
+      relativePath = './' + relativePath;
     }
-    // Make an array of `..` to get our importPath to the root directory.
-    const a = new Array(numberOfDirs);
-    const prefix = a.fill('..', 0, numberOfDirs).join('/');
-    return prefix + importPath.substring(1);
+    return relativePath;
 }
 exports.maybeRelativePath = maybeRelativePath;
 /** Checks if `path1 === path2` despite minor path differences like `./foo` and `foo`. */
