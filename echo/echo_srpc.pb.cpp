//go:build deps_only

// Code generated by protoc-gen-starpc-cpp. DO NOT EDIT.
// protoc-gen-starpc-cpp version: v0.45.1-0.20260203090429-3e915608d4e8
// source: github.com/aperturerobotics/starpc/echo/echo.proto

#include "echo_srpc.pb.hpp"

namespace echo {

starpc::Error SRPCEchoerClientImpl::Echo(const echo::EchoMsg& in, echo::EchoMsg* out) {
  return cc_->ExecCall(service_id_, "Echo", in, out);
}

std::pair<std::unique_ptr<SRPCEchoer_EchoServerStreamClient>, starpc::Error> SRPCEchoerClientImpl::EchoServerStream(const echo::EchoMsg& in) {
  auto [strm, err] = cc_->NewStream(service_id_, "EchoServerStream", &in);
  if (err != starpc::Error::OK) {
    return {nullptr, err};
  }
  err = strm->CloseSend();
  if (err != starpc::Error::OK) {
    return {nullptr, err};
  }
  return {std::make_unique<SRPCEchoer_EchoServerStreamClient>(std::move(strm)), starpc::Error::OK};
}

std::pair<std::unique_ptr<SRPCEchoer_EchoClientStreamClient>, starpc::Error> SRPCEchoerClientImpl::EchoClientStream() {
  auto [strm, err] = cc_->NewStream(service_id_, "EchoClientStream", nullptr);
  if (err != starpc::Error::OK) {
    return {nullptr, err};
  }
  return {std::make_unique<SRPCEchoer_EchoClientStreamClient>(std::move(strm)), starpc::Error::OK};
}

std::pair<std::unique_ptr<SRPCEchoer_EchoBidiStreamClient>, starpc::Error> SRPCEchoerClientImpl::EchoBidiStream() {
  auto [strm, err] = cc_->NewStream(service_id_, "EchoBidiStream", nullptr);
  if (err != starpc::Error::OK) {
    return {nullptr, err};
  }
  return {std::make_unique<SRPCEchoer_EchoBidiStreamClient>(std::move(strm)), starpc::Error::OK};
}

std::pair<std::unique_ptr<SRPCEchoer_RpcStreamClient>, starpc::Error> SRPCEchoerClientImpl::RpcStream() {
  auto [strm, err] = cc_->NewStream(service_id_, "RpcStream", nullptr);
  if (err != starpc::Error::OK) {
    return {nullptr, err};
  }
  return {std::make_unique<SRPCEchoer_RpcStreamClient>(std::move(strm)), starpc::Error::OK};
}

starpc::Error SRPCEchoerClientImpl::DoNothing(const google::protobuf::Empty& in, google::protobuf::Empty* out) {
  return cc_->ExecCall(service_id_, "DoNothing", in, out);
}

std::vector<std::string> SRPCEchoerHandler::GetMethodIDs() const {
  return {
    "Echo",
    "EchoServerStream",
    "EchoClientStream",
    "EchoBidiStream",
    "RpcStream",
    "DoNothing",
  };
}

std::pair<bool, starpc::Error> SRPCEchoerHandler::InvokeMethod(
    const std::string& service_id,
    const std::string& method_id,
    starpc::Stream* strm) {
  if (!service_id.empty() && service_id != service_id_) {
    return {false, starpc::Error::OK};
  }

  if (method_id == "Echo") {
    echo::EchoMsg req;
    starpc::Error err = strm->MsgRecv(&req);
    if (err != starpc::Error::OK) return {true, err};
    echo::EchoMsg resp;
    err = impl_->Echo(req, &resp);
    if (err != starpc::Error::OK) return {true, err};
    return {true, strm->MsgSend(resp)};
  } else if (method_id == "EchoServerStream") {
    echo::EchoMsg req;
    starpc::Error err = strm->MsgRecv(&req);
    if (err != starpc::Error::OK) return {true, err};
    SRPCEchoer_EchoServerStreamStream serverStrm(strm);
    return {true, impl_->EchoServerStream(req, &serverStrm)};
  } else if (method_id == "EchoClientStream") {
    SRPCEchoer_EchoClientStreamStream clientStrm(strm);
    echo::EchoMsg resp;
    starpc::Error err = impl_->EchoClientStream(&clientStrm, &resp);
    if (err != starpc::Error::OK) return {true, err};
    return {true, strm->MsgSend(resp)};
  } else if (method_id == "EchoBidiStream") {
    SRPCEchoer_EchoBidiStreamStream bidiStrm(strm);
    return {true, impl_->EchoBidiStream(&bidiStrm)};
  } else if (method_id == "RpcStream") {
    SRPCEchoer_RpcStreamStream bidiStrm(strm);
    return {true, impl_->RpcStream(&bidiStrm)};
  } else if (method_id == "DoNothing") {
    google::protobuf::Empty req;
    starpc::Error err = strm->MsgRecv(&req);
    if (err != starpc::Error::OK) return {true, err};
    google::protobuf::Empty resp;
    err = impl_->DoNothing(req, &resp);
    if (err != starpc::Error::OK) return {true, err};
    return {true, strm->MsgSend(resp)};
  }

  return {false, starpc::Error::OK};
}

}  // namespace echo
