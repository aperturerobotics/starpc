// Code generated by protoc-gen-starpc-rust. DO NOT EDIT.
// protoc-gen-starpc-rust version: v0.45.1-0.20260203090429-3e915608d4e8
// source: github.com/aperturerobotics/starpc/echo/echo.proto

#[allow(unused_imports)]
use starpc::StreamExt;

/// Service ID for Echoer.
pub const ECHOER_SERVICE_ID: &str = "echo.Echoer";

/// Stream trait for Echoer.EchoServerStream.
#[starpc::async_trait]
pub trait EchoerEchoServerStreamStream: Send + Sync {
    /// Returns the context for this stream.
    fn context(&self) -> &starpc::Context;
    /// Receives a message from the stream.
    async fn recv(&self) -> starpc::Result<EchoMsg>;
    /// Closes the stream.
    async fn close(&self) -> starpc::Result<()>;
}

/// Stream trait for Echoer.EchoClientStream.
#[starpc::async_trait]
pub trait EchoerEchoClientStreamStream: Send + Sync {
    /// Returns the context for this stream.
    fn context(&self) -> &starpc::Context;
    /// Sends a message on the stream.
    async fn send(&self, msg: &EchoMsg) -> starpc::Result<()>;
    /// Closes the send side and receives the response.
    async fn close_and_recv(&self) -> starpc::Result<EchoMsg>;
}

/// Stream trait for Echoer.EchoBidiStream.
#[starpc::async_trait]
pub trait EchoerEchoBidiStreamStream: Send + Sync {
    /// Returns the context for this stream.
    fn context(&self) -> &starpc::Context;
    /// Sends a message on the stream.
    async fn send(&self, msg: &EchoMsg) -> starpc::Result<()>;
    /// Receives a message from the stream.
    async fn recv(&self) -> starpc::Result<EchoMsg>;
    /// Closes the stream.
    async fn close(&self) -> starpc::Result<()>;
}

/// Stream trait for Echoer.RpcStream.
#[starpc::async_trait]
pub trait EchoerRpcStreamStream: Send + Sync {
    /// Returns the context for this stream.
    fn context(&self) -> &starpc::Context;
    /// Sends a message on the stream.
    async fn send(&self, msg: &RpcStreamPacket) -> starpc::Result<()>;
    /// Receives a message from the stream.
    async fn recv(&self) -> starpc::Result<RpcStreamPacket>;
    /// Closes the stream.
    async fn close(&self) -> starpc::Result<()>;
}

/// Client trait for Echoer.
#[starpc::async_trait]
pub trait EchoerClient: Send + Sync {
    /// Echo.
    async fn echo(&self, request: &EchoMsg) -> starpc::Result<EchoMsg>;
    /// EchoServerStream.
    async fn echo_server_stream(&self, request: &EchoMsg) -> starpc::Result<Box<dyn EchoerEchoServerStreamStream>>;
    /// EchoClientStream.
    async fn echo_client_stream(&self) -> starpc::Result<Box<dyn EchoerEchoClientStreamStream>>;
    /// EchoBidiStream.
    async fn echo_bidi_stream(&self) -> starpc::Result<Box<dyn EchoerEchoBidiStreamStream>>;
    /// RpcStream.
    async fn rpc_stream(&self) -> starpc::Result<Box<dyn EchoerRpcStreamStream>>;
    /// DoNothing.
    async fn do_nothing(&self, request: &Empty) -> starpc::Result<Empty>;
}

/// Client implementation for Echoer.
pub struct EchoerClientImpl<C> {
    client: C,
}

impl<C: starpc::Client> EchoerClientImpl<C> {
    /// Creates a new client.
    pub fn new(client: C) -> Self {
        Self { client }
    }
}

#[starpc::async_trait]
impl<C: starpc::Client + 'static> EchoerClient for EchoerClientImpl<C> {
    async fn echo(&self, request: &EchoMsg) -> starpc::Result<EchoMsg> {
        self.client.exec_call("echo.Echoer", "Echo", request).await
    }
    async fn echo_server_stream(&self, request: &EchoMsg) -> starpc::Result<Box<dyn EchoerEchoServerStreamStream>> {
        use starpc::ProstMessage;
        let data = request.encode_to_vec();
        let stream = self.client.new_stream("echo.Echoer", "EchoServerStream", Some(&data)).await?;
        stream.close_send().await?;
        Ok(Box::new(EchoerEchoServerStreamStreamImpl { stream }))
    }
    async fn echo_client_stream(&self) -> starpc::Result<Box<dyn EchoerEchoClientStreamStream>> {
        let stream = self.client.new_stream("echo.Echoer", "EchoClientStream", None).await?;
        Ok(Box::new(EchoerEchoClientStreamStreamImpl { stream }))
    }
    async fn echo_bidi_stream(&self) -> starpc::Result<Box<dyn EchoerEchoBidiStreamStream>> {
        let stream = self.client.new_stream("echo.Echoer", "EchoBidiStream", None).await?;
        Ok(Box::new(EchoerEchoBidiStreamStreamImpl { stream }))
    }
    async fn rpc_stream(&self) -> starpc::Result<Box<dyn EchoerRpcStreamStream>> {
        let stream = self.client.new_stream("echo.Echoer", "RpcStream", None).await?;
        Ok(Box::new(EchoerRpcStreamStreamImpl { stream }))
    }
    async fn do_nothing(&self, request: &Empty) -> starpc::Result<Empty> {
        self.client.exec_call("echo.Echoer", "DoNothing", request).await
    }
}

struct EchoerEchoServerStreamStreamImpl {
    stream: Box<dyn starpc::Stream>,
}

#[starpc::async_trait]
impl EchoerEchoServerStreamStream for EchoerEchoServerStreamStreamImpl {
    fn context(&self) -> &starpc::Context {
        self.stream.context()
    }
    async fn recv(&self) -> starpc::Result<EchoMsg> {
        self.stream.msg_recv().await
    }
    async fn close(&self) -> starpc::Result<()> {
        self.stream.close().await
    }
}

struct EchoerEchoClientStreamStreamImpl {
    stream: Box<dyn starpc::Stream>,
}

#[starpc::async_trait]
impl EchoerEchoClientStreamStream for EchoerEchoClientStreamStreamImpl {
    fn context(&self) -> &starpc::Context {
        self.stream.context()
    }
    async fn send(&self, msg: &EchoMsg) -> starpc::Result<()> {
        self.stream.msg_send(msg).await
    }
    async fn close_and_recv(&self) -> starpc::Result<EchoMsg> {
        self.stream.close_send().await?;
        self.stream.msg_recv().await
    }
}

struct EchoerEchoBidiStreamStreamImpl {
    stream: Box<dyn starpc::Stream>,
}

#[starpc::async_trait]
impl EchoerEchoBidiStreamStream for EchoerEchoBidiStreamStreamImpl {
    fn context(&self) -> &starpc::Context {
        self.stream.context()
    }
    async fn send(&self, msg: &EchoMsg) -> starpc::Result<()> {
        self.stream.msg_send(msg).await
    }
    async fn recv(&self) -> starpc::Result<EchoMsg> {
        self.stream.msg_recv().await
    }
    async fn close(&self) -> starpc::Result<()> {
        self.stream.close().await
    }
}

struct EchoerRpcStreamStreamImpl {
    stream: Box<dyn starpc::Stream>,
}

#[starpc::async_trait]
impl EchoerRpcStreamStream for EchoerRpcStreamStreamImpl {
    fn context(&self) -> &starpc::Context {
        self.stream.context()
    }
    async fn send(&self, msg: &RpcStreamPacket) -> starpc::Result<()> {
        self.stream.msg_send(msg).await
    }
    async fn recv(&self) -> starpc::Result<RpcStreamPacket> {
        self.stream.msg_recv().await
    }
    async fn close(&self) -> starpc::Result<()> {
        self.stream.close().await
    }
}

/// Server trait for Echoer.
#[starpc::async_trait]
pub trait EchoerServer: Send + Sync {
    /// Echo.
    async fn echo(&self, request: EchoMsg) -> starpc::Result<EchoMsg>;
    /// EchoServerStream.
    async fn echo_server_stream(&self, request: EchoMsg, stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;
    /// EchoClientStream.
    async fn echo_client_stream(&self, stream: &dyn starpc::Stream) -> starpc::Result<EchoMsg>;
    /// EchoBidiStream.
    async fn echo_bidi_stream(&self, stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;
    /// RpcStream.
    async fn rpc_stream(&self, stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;
    /// DoNothing.
    async fn do_nothing(&self, request: Empty) -> starpc::Result<Empty>;
}

const ECHOER_METHOD_IDS: &[&str] = &[
    "Echo",
    "EchoServerStream",
    "EchoClientStream",
    "EchoBidiStream",
    "RpcStream",
    "DoNothing",
];

/// Handler for Echoer.
pub struct EchoerHandler<S: EchoerServer> {
    server: std::sync::Arc<S>,
}

impl<S: EchoerServer + 'static> EchoerHandler<S> {
    /// Creates a new handler wrapping the server implementation.
    pub fn new(server: S) -> Self {
        Self { server: std::sync::Arc::new(server) }
    }

    /// Creates a new handler with a shared server.
    pub fn with_arc(server: std::sync::Arc<S>) -> Self {
        Self { server }
    }
}

#[starpc::async_trait]
impl<S: EchoerServer + 'static> starpc::Invoker for EchoerHandler<S> {
    async fn invoke_method(
        &self,
        _service_id: &str,
        method_id: &str,
        stream: Box<dyn starpc::Stream>,
    ) -> (bool, starpc::Result<()>) {
        match method_id {
            "Echo" => {
                let request: EchoMsg = match stream.msg_recv().await {
                    Ok(r) => r,
                    Err(e) => return (true, Err(e)),
                };
                match self.server.echo(request).await {
                    Ok(response) => {
                        if let Err(e) = stream.msg_send(&response).await {
                            return (true, Err(e));
                        }
                        (true, Ok(()))
                    }
                    Err(e) => (true, Err(e)),
                }
            }
            "EchoServerStream" => {
                let request: EchoMsg = match stream.msg_recv().await {
                    Ok(r) => r,
                    Err(e) => return (true, Err(e)),
                };
                (true, self.server.echo_server_stream(request, stream).await)
            }
            "EchoClientStream" => {
                match self.server.echo_client_stream(stream.as_ref()).await {
                    Ok(response) => {
                        if let Err(e) = stream.msg_send(&response).await {
                            return (true, Err(e));
                        }
                        (true, Ok(()))
                    }
                    Err(e) => (true, Err(e)),
                }
            }
            "EchoBidiStream" => {
                (true, self.server.echo_bidi_stream(stream).await)
            }
            "RpcStream" => {
                (true, self.server.rpc_stream(stream).await)
            }
            "DoNothing" => {
                let request: Empty = match stream.msg_recv().await {
                    Ok(r) => r,
                    Err(e) => return (true, Err(e)),
                };
                match self.server.do_nothing(request).await {
                    Ok(response) => {
                        if let Err(e) = stream.msg_send(&response).await {
                            return (true, Err(e));
                        }
                        (true, Ok(()))
                    }
                    Err(e) => (true, Err(e)),
                }
            }
            _ => (false, Err(starpc::Error::Unimplemented)),
        }
    }
}

impl<S: EchoerServer + 'static> starpc::Handler for EchoerHandler<S> {
    fn service_id(&self) -> &'static str {
        "echo.Echoer"
    }

    fn method_ids(&self) -> &'static [&'static str] {
        ECHOER_METHOD_IDS
    }
}

