// @generated by protoc-gen-connect-es v1.4.0 with parameter "target=ts"
// @generated from file github.com/aperturerobotics/starpc/echo/echo.proto (package echo, syntax proto3)
/* eslint-disable */

import { EchoMsg } from './echo.pb.js'
import { BinaryReadOptions, Message, MethodKind } from '@bufbuild/protobuf'
import { RpcStreamPacket } from '../rpcstream/rpcstream.pb.js'
import { ProtoRpc } from '../srpc/proto-rpc.js' // todo: starpc

/**
 * Echoer service returns the given message.
 *
 * @generated from service echo.Echoer
 */
export const Echoer = {
  typeName: 'echo.Echoer',
  methods: {
    /**
     * Echo returns the given message.
     *
     * @generated from rpc echo.Echoer.Echo
     */
    echo: {
      name: 'Echo',
      I: EchoMsg,
      O: EchoMsg,
      kind: MethodKind.Unary,
    },
    /**
     * EchoServerStream is an example of a server -> client one-way stream.
     *
     * @generated from rpc echo.Echoer.EchoServerStream
     */
    echoServerStream: {
      name: 'EchoServerStream',
      I: EchoMsg,
      O: EchoMsg,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * EchoClientStream is an example of client->server one-way stream.
     *
     * @generated from rpc echo.Echoer.EchoClientStream
     */
    echoClientStream: {
      name: 'EchoClientStream',
      I: EchoMsg,
      O: EchoMsg,
      kind: MethodKind.ClientStreaming,
    },
    /**
     * EchoBidiStream is an example of a two-way stream.
     *
     * @generated from rpc echo.Echoer.EchoBidiStream
     */
    echoBidiStream: {
      name: 'EchoBidiStream',
      I: EchoMsg,
      O: EchoMsg,
      kind: MethodKind.BiDiStreaming,
    },
    /**
     * RpcStream opens a nested rpc call stream.
     *
     * @generated from rpc echo.Echoer.RpcStream
     */
    rpcStream: {
      name: 'RpcStream',
      I: RpcStreamPacket,
      O: RpcStreamPacket,
      kind: MethodKind.BiDiStreaming,
    },
  },
} as const

// TODO: move to common lib

async function* encodeTransform<T extends Message>(
  source: AsyncIterable<T | T[]> | Iterable<T | T[]>,
): AsyncIterable<Uint8Array> {
  for await (const pkt of source) {
    if (Array.isArray(pkt)) {
      for (const p of pkt) {
        yield p.toBinary()
      }
    } else {
      yield pkt.toBinary()
    }
  }
}

async function* decodeTransform<T extends Message>(
  messageType: {
    fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): T
  },
  source:
    | AsyncIterable<Uint8Array | Uint8Array[]>
    | Iterable<Uint8Array | Uint8Array[]>,
): AsyncIterable<T> {
  for await (const pkt of source) {
    if (Array.isArray(pkt)) {
      for (const p of pkt) {
        yield messageType.fromBinary(p)
      }
    } else {
      yield messageType.fromBinary(pkt)
    }
  }
}

/** Echoer service returns the given message. */
export interface Echoer {
  /** Echo returns the given message. */
  Echo(request: EchoMsg, abortSignal?: AbortSignal): Promise<EchoMsg>
  /** EchoServerStream is an example of a server -> client one-way stream. */
  EchoServerStream(
    request: EchoMsg,
    abortSignal?: AbortSignal,
  ): AsyncIterable<EchoMsg>
  /** EchoClientStream is an example of client->server one-way stream. */
  EchoClientStream(
    request: AsyncIterable<EchoMsg>,
    abortSignal?: AbortSignal,
  ): Promise<EchoMsg>
  /** EchoBidiStream is an example of a two-way stream. */
  EchoBidiStream(
    request: AsyncIterable<EchoMsg>,
    abortSignal?: AbortSignal,
  ): AsyncIterable<EchoMsg>
  /** RpcStream opens a nested rpc call stream. */
  RpcStream(
    request: AsyncIterable<RpcStreamPacket>,
    abortSignal?: AbortSignal,
  ): AsyncIterable<RpcStreamPacket>
}

export const EchoerServiceName = 'echo.Echoer'

export class EchoerClientImpl implements Echoer {
  private readonly rpc: ProtoRpc
  private readonly service: string

  constructor(rpc: ProtoRpc, opts?: { service?: string }) {
    this.service = opts?.service || EchoerServiceName
    this.rpc = rpc
    this.Echo = this.Echo.bind(this)
    this.EchoServerStream = this.EchoServerStream.bind(this)
    this.EchoClientStream = this.EchoClientStream.bind(this)
    this.EchoBidiStream = this.EchoBidiStream.bind(this)
    this.RpcStream = this.RpcStream.bind(this)
  }

  async Echo(request: EchoMsg, abortSignal?: AbortSignal): Promise<EchoMsg> {
    const result = await this.rpc.request(
      this.service,
      'Echo',
      request.toBinary(),
      abortSignal || undefined,
    )
    return EchoMsg.fromBinary(result)
  }

  EchoServerStream(
    request: EchoMsg,
    abortSignal?: AbortSignal,
  ): AsyncIterable<EchoMsg> {
    const result = this.rpc.serverStreamingRequest(
      this.service,
      'EchoServerStream',
      request.toBinary(),
      abortSignal || undefined,
    )
    return decodeTransform(EchoMsg, result)
  }

  async EchoClientStream(
    request: AsyncIterable<EchoMsg>,
    abortSignal?: AbortSignal,
  ): Promise<EchoMsg> {
    const result = await this.rpc.clientStreamingRequest(
      this.service,
      'EchoClientStream',
      encodeTransform(request),
      abortSignal || undefined,
    )
    return EchoMsg.decode(_m0.Reader.create(result))
  }

  EchoBidiStream(
    request: AsyncIterable<EchoMsg>,
    abortSignal?: AbortSignal,
  ): AsyncIterable<EchoMsg> {
    const data = EchoMsg.encodeTransform(request)
    const result = this.rpc.bidirectionalStreamingRequest(
      this.service,
      'EchoBidiStream',
      data,
      abortSignal || undefined,
    )
    return EchoMsg.decodeTransform(result)
  }

  RpcStream(
    request: AsyncIterable<RpcStreamPacket>,
    abortSignal?: AbortSignal,
  ): AsyncIterable<RpcStreamPacket> {
    const data = RpcStreamPacket.encodeTransform(request)
    const result = this.rpc.bidirectionalStreamingRequest(
      this.service,
      'RpcStream',
      data,
      abortSignal || undefined,
    )
    return RpcStreamPacket.decodeTransform(result)
  }
}
